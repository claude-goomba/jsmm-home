<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Insane Jump - JSMM Games</title>
  <style>
    body {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #fff;
      font-family: 'Segoe UI', Arial, sans-serif;
      margin: 0;
      padding: 20px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      overflow-x: hidden;
      overflow-y: auto;
    }

    #gameContainer {
      background: rgba(35, 43, 58, 0.8);
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
      text-align: center;
      max-width: 900px;
    }

    h1 {
      color: #efc050;
      font-size: 3em;
      margin: 0 0 10px 0;
      text-shadow: 0 0 20px rgba(239, 192, 80, 0.6);
    }

    .subtitle {
      color: #45b8ac;
      font-size: 1.2em;
      margin-bottom: 20px;
    }

    #gameCanvas {
      background: #000;
      border-radius: 12px;
      display: block;
      margin: 20px auto;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
      cursor: none;
      border: 4px solid #efc050;
    }

    .stats {
      display: flex;
      justify-content: space-around;
      margin: 20px 0;
      font-size: 1.3em;
      gap: 30px;
    }

    .stat {
      background: rgba(0, 0, 0, 0.3);
      padding: 15px 30px;
      border-radius: 12px;
      border: 2px solid #efc050;
      flex: 1;
    }

    .stat-label {
      color: #b3b3b3;
      font-size: 0.8em;
    }

    .stat-value {
      color: #efc050;
      font-size: 1.5em;
      font-weight: bold;
    }

    .controls {
      background: rgba(0, 0, 0, 0.3);
      padding: 20px;
      border-radius: 12px;
      margin-top: 20px;
      text-align: left;
    }

    .controls h3 {
      color: #efc050;
      margin-top: 0;
    }

    .controls p {
      color: #b3b3b3;
      margin: 8px 0;
      font-size: 1.1em;
    }

    .key {
      display: inline-block;
      background: #45b8ac;
      color: #fff;
      padding: 5px 12px;
      border-radius: 6px;
      font-weight: bold;
      margin: 0 5px;
    }

    button {
      background: linear-gradient(135deg, #efc050, #ff9800);
      color: #fff;
      border: none;
      padding: 15px 40px;
      border-radius: 10px;
      font-size: 1.2em;
      font-weight: bold;
      cursor: pointer;
      margin: 10px;
      box-shadow: 0 4px 16px rgba(239, 192, 80, 0.4);
      transition: all 0.3s ease;
    }

    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(239, 192, 80, 0.6);
    }

    button:active {
      transform: translateY(-1px);
    }

    #gameOver {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.9);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .gameOverContent {
      background: rgba(35, 43, 58, 0.95);
      padding: 50px;
      border-radius: 20px;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
      border: 3px solid #efc050;
    }

    .gameOverContent h2 {
      color: #efc050;
      font-size: 3em;
      margin: 0 0 20px 0;
    }

    .gameOverContent p {
      color: #b3b3b3;
      font-size: 1.5em;
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <h1>üèì Insane Jump Pong</h1>
    <p class="subtitle">Classic arcade action!</p>

    <div class="stats">
      <div class="stat">
        <div class="stat-label">Player</div>
        <div class="stat-value" id="playerScore">0</div>
      </div>
      <div class="stat">
        <div class="stat-label">Rally</div>
        <div class="stat-value" id="rally">0</div>
      </div>
      <div class="stat">
        <div class="stat-label">CPU</div>
        <div class="stat-value" id="cpuScore">0</div>
      </div>
    </div>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div class="controls">
      <h3>Controls</h3>
      <p><span class="key">MOUSE</span> Move paddle up and down</p>
      <p><span class="key">W</span> <span class="key">S</span> Alternative paddle controls</p>
      <p><span class="key">CLICK</span> Start game</p>
      <p style="margin-top: 10px; color: #efc050;">First to 10 points wins!</p>
    </div>

    <div>
      <button onclick="resetGame()">New Game</button>
      <a href="index.html" style="text-decoration: none;"><button>Back to Home</button></a>
    </div>
  </div>

  <div id="gameOver">
    <div class="gameOverContent">
      <h2 id="winnerText">You Win!</h2>
      <p>Final Score: <span id="finalPlayerScore">0</span> - <span id="finalCPUScore">0</span></p>
      <button onclick="resetGame()">Play Again</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Intro animation state
    let intro = {
      active: true,
      phase: 0, // 0: pong timelapse, 1: JSMM logo, 2: fade to game
      frame: 0,
      ball: { x: 400, y: 300, vx: 8, vy: 5 },
      paddle1: { y: 240 },
      paddle2: { y: 240 },
      scores: [0, 0],
      logoAlpha: 0,
      fadeAlpha: 0
    };

    // Game state
    let game = {
      running: false,
      playerScore: 0,
      cpuScore: 0,
      rally: 0,
      maxScore: 10,
      mouseY: canvas.height / 2,
      player: {
        x: 30,
        y: canvas.height / 2 - 60,
        width: 15,
        height: 120,
        speed: 8
      },
      cpu: {
        x: canvas.width - 45,
        y: canvas.height / 2 - 60,
        width: 15,
        height: 120,
        speed: 3
      },
      ball: {
        x: canvas.width / 2,
        y: canvas.height / 2,
        radius: 10,
        velocityX: 4,
        velocityY: 2.5,
        speed: 4,
        trail: []
      },
      particles: [],
      keys: {},
      replay: {
        active: false,
        frames: [],
        currentFrame: 0,
        maxFrames: 60, // Record last 60 frames (about 1 second at 60fps)
        scoredBy: null
      }
    };

    // Mouse controls
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      game.mouseY = e.clientY - rect.top;
    });

    canvas.addEventListener('click', (e) => {
      if (!game.running) {
        startGame();
      }
    });

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      game.keys[e.key.toLowerCase()] = true;
      if (!game.running && e.key === ' ') {
        e.preventDefault();
        startGame();
      }
    });

    document.addEventListener('keyup', (e) => {
      game.keys[e.key.toLowerCase()] = false;
    });

    // Create particles
    function createParticles(x, y, color, count = 15) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 4 + 2;
        game.particles.push({
          x: x,
          y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 30,
          color: color,
          size: Math.random() * 3 + 2
        });
      }
    }

    // Reset ball
    function resetBall() {
      game.ball.x = canvas.width / 2;
      game.ball.y = canvas.height / 2;
      game.ball.velocityX = (Math.random() > 0.5 ? 1 : -1) * game.ball.speed;
      game.ball.velocityY = (Math.random() - 0.5) * 2.5;
      game.ball.trail = [];
      game.rally = 0;
    }

    // Record frame for replay
    function recordFrame() {
      game.replay.frames.push({
        ballX: game.ball.x,
        ballY: game.ball.y,
        playerY: game.player.y,
        cpuY: game.cpu.y
      });

      // Keep only last N frames
      if (game.replay.frames.length > game.replay.maxFrames) {
        game.replay.frames.shift();
      }
    }

    // Play replay
    function playReplay(scorer) {
      game.replay.active = true;
      game.replay.currentFrame = 0;
      game.replay.scoredBy = scorer;
    }

    // Update intro animation
    function updateIntro() {
      if (!intro.active) return;

      intro.frame++;

      if (intro.phase === 0) {
        // Time-lapse pong match
        intro.ball.x += intro.ball.vx;
        intro.ball.y += intro.ball.vy;

        // Bounce off top/bottom
        if (intro.ball.y <= 10 || intro.ball.y >= 590) {
          intro.ball.vy *= -1;
          intro.ball.y = intro.ball.y <= 10 ? 10 : 590;
        }

        // Paddle AI (fast)
        intro.paddle1.y += (intro.ball.y - intro.paddle1.y - 60) * 0.3;
        intro.paddle2.y += (intro.ball.y - intro.paddle2.y - 60) * 0.3;

        // Paddle collisions
        if (intro.ball.x <= 40 && intro.ball.y > intro.paddle1.y && intro.ball.y < intro.paddle1.y + 120) {
          intro.ball.vx = Math.abs(intro.ball.vx);
        }
        if (intro.ball.x >= 760 && intro.ball.y > intro.paddle2.y && intro.ball.y < intro.paddle2.y + 120) {
          intro.ball.vx = -Math.abs(intro.ball.vx);
        }

        // Scoring
        if (intro.ball.x < 0) {
          intro.scores[1]++;
          intro.ball.x = 400;
          intro.ball.y = 300;
          intro.ball.vx = 8;
        } else if (intro.ball.x > 800) {
          intro.scores[0]++;
          intro.ball.x = 400;
          intro.ball.y = 300;
          intro.ball.vx = -8;
        }

        // Transition to logo after 180 frames (3 seconds at 60fps)
        if (intro.frame > 180) {
          intro.phase = 1;
          intro.frame = 0;
        }
      } else if (intro.phase === 1) {
        // JSMM logo fade in
        intro.logoAlpha = Math.min(1, intro.logoAlpha + 0.02);

        // Hold logo for 120 frames (2 seconds)
        if (intro.frame > 120 && intro.logoAlpha >= 1) {
          intro.phase = 2;
          intro.frame = 0;
        }
      } else if (intro.phase === 2) {
        // Fade out to game
        intro.fadeAlpha = Math.min(1, intro.fadeAlpha + 0.03);

        if (intro.fadeAlpha >= 1) {
          intro.active = false;
        }
      }
    }

    // Draw intro animation
    function drawIntro() {
      if (!intro.active) return;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (intro.phase === 0) {
        // Draw time-lapse pong match
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(400, 0);
        ctx.lineTo(400, 600);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw paddles
        ctx.fillStyle = '#45b8ac';
        ctx.fillRect(30, intro.paddle1.y, 10, 120);
        ctx.fillStyle = '#ff6b6b';
        ctx.fillRect(760, intro.paddle2.y, 10, 120);

        // Draw ball
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(intro.ball.x, intro.ball.y, 8, 0, Math.PI * 2);
        ctx.fill();

        // Draw scores
        ctx.fillStyle = '#45b8ac';
        ctx.font = 'bold 48px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(intro.scores[0].toString(), 200, 80);
        ctx.fillStyle = '#ff6b6b';
        ctx.fillText(intro.scores[1].toString(), 600, 80);
      } else if (intro.phase === 1) {
        // Draw JSMM logo
        ctx.save();
        ctx.globalAlpha = intro.logoAlpha;

        // Background gradient
        const grad = ctx.createRadialGradient(400, 300, 0, 400, 300, 400);
        grad.addColorStop(0, '#1a1a2e');
        grad.addColorStop(1, '#000');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // JSMM text with glow
        ctx.shadowColor = '#efc050';
        ctx.shadowBlur = 40;
        ctx.fillStyle = '#efc050';
        ctx.font = 'bold 120px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('JSMM', 400, 320);

        // Subtitle
        ctx.shadowBlur = 20;
        ctx.fillStyle = '#45b8ac';
        ctx.font = 'bold 28px monospace';
        ctx.fillText('Josh ¬∑ Storm ¬∑ Manu ¬∑ Miles', 400, 380);

        ctx.restore();
      } else if (intro.phase === 2) {
        // Fade to white
        ctx.fillStyle = `rgba(255, 255, 255, ${intro.fadeAlpha})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    // Update game
    function update() {
      if (!game.running) return;

      // Handle replay mode
      if (game.replay.active) {
        if (game.replay.currentFrame < game.replay.frames.length) {
          const frame = game.replay.frames[game.replay.currentFrame];
          game.ball.x = frame.ballX;
          game.ball.y = frame.ballY;
          game.player.y = frame.playerY;
          game.cpu.y = frame.cpuY;
          game.replay.currentFrame++;
        } else {
          // Replay finished
          game.replay.active = false;
          game.replay.frames = [];
          resetBall();
        }
        return;
      }

      // Update player paddle (follow mouse)
      const targetY = game.mouseY - game.player.height / 2;
      game.player.y += (targetY - game.player.y) * 0.2;

      // Keyboard controls for player
      if (game.keys['w']) {
        game.player.y -= game.player.speed;
      }
      if (game.keys['s']) {
        game.player.y += game.player.speed;
      }

      // Keep player paddle in bounds
      game.player.y = Math.max(0, Math.min(canvas.height - game.player.height, game.player.y));

      // CPU AI - follow ball with some delay
      const cpuCenter = game.cpu.y + game.cpu.height / 2;
      const ballY = game.ball.y;

      if (cpuCenter < ballY - 50) {
        game.cpu.y += game.cpu.speed;
      } else if (cpuCenter > ballY + 50) {
        game.cpu.y -= game.cpu.speed;
      }

      // Keep CPU paddle in bounds
      game.cpu.y = Math.max(0, Math.min(canvas.height - game.cpu.height, game.cpu.y));

      // Update ball
      game.ball.x += game.ball.velocityX;
      game.ball.y += game.ball.velocityY;

      // Ball trail
      game.ball.trail.push({ x: game.ball.x, y: game.ball.y });
      if (game.ball.trail.length > 8) {
        game.ball.trail.shift();
      }

      // Top and bottom wall collision
      if (game.ball.y - game.ball.radius < 0 || game.ball.y + game.ball.radius > canvas.height) {
        game.ball.velocityY *= -1;
        game.ball.y = game.ball.y < canvas.height / 2 ? game.ball.radius : canvas.height - game.ball.radius;
        createParticles(game.ball.x, game.ball.y, '#45b8ac', 10);
      }

      // Player paddle collision
      if (game.ball.x - game.ball.radius < game.player.x + game.player.width &&
          game.ball.x + game.ball.radius > game.player.x &&
          game.ball.y > game.player.y &&
          game.ball.y < game.player.y + game.player.height) {

        // Calculate hit position on paddle
        const hitPos = (game.ball.y - (game.player.y + game.player.height / 2)) / (game.player.height / 2);
        game.ball.velocityY = hitPos * 4;
        game.ball.velocityX = Math.abs(game.ball.velocityX);
        game.ball.x = game.player.x + game.player.width + game.ball.radius;

        game.rally++;
        createParticles(game.ball.x, game.ball.y, '#efc050', 15);
      }

      // CPU paddle collision
      if (game.ball.x + game.ball.radius > game.cpu.x &&
          game.ball.x - game.ball.radius < game.cpu.x + game.cpu.width &&
          game.ball.y > game.cpu.y &&
          game.ball.y < game.cpu.y + game.cpu.height) {

        const hitPos = (game.ball.y - (game.cpu.y + game.cpu.height / 2)) / (game.cpu.height / 2);
        game.ball.velocityY = hitPos * 4;
        game.ball.velocityX = -Math.abs(game.ball.velocityX);
        game.ball.x = game.cpu.x - game.ball.radius;

        game.rally++;
        createParticles(game.ball.x, game.ball.y, '#ff6b6b', 15);
      }

      // Score - ball out of bounds
      if (game.ball.x < 0) {
        game.cpuScore++;
        createParticles(game.ball.x, game.ball.y, '#ff0000', 30);
        if (game.cpuScore >= game.maxScore) {
          endGame('CPU');
        } else {
          playReplay('CPU');
        }
      } else if (game.ball.x > canvas.width) {
        game.playerScore++;
        createParticles(game.ball.x, game.ball.y, '#00ff00', 30);
        if (game.playerScore >= game.maxScore) {
          endGame('Player');
        } else {
          playReplay('Player');
        }
      }

      // Update particles
      game.particles.forEach((p, i) => {
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) {
          game.particles.splice(i, 1);
        }
      });

      // Record frame for replay
      recordFrame();

      updateUI();
    }

    // Draw game
    function draw() {
      // Clear canvas (black background)
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw center line (dashed)
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 3;
      ctx.setLineDash([10, 10]);
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 0);
      ctx.lineTo(canvas.width / 2, canvas.height);
      ctx.stroke();
      ctx.setLineDash([]);

      // Draw scores (large, centered at top)
      ctx.fillStyle = '#45b8ac';
      ctx.font = 'bold 48px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(game.playerScore.toString(), canvas.width / 4, 60);

      ctx.fillStyle = '#ff6b6b';
      ctx.fillText(game.cpuScore.toString(), (canvas.width / 4) * 3, 60);

      // Draw rally counter (center top)
      if (game.rally > 0) {
        ctx.fillStyle = '#efc050';
        ctx.font = 'bold 24px monospace';
        ctx.fillText('Rally: ' + game.rally, canvas.width / 2, 30);
      }

      // Draw player paddle (left - bright cyan)
      ctx.fillStyle = '#45b8ac';
      ctx.fillRect(game.player.x, game.player.y, game.player.width, game.player.height);

      // Paddle glow
      ctx.shadowColor = '#45b8ac';
      ctx.shadowBlur = 20;
      ctx.fillRect(game.player.x, game.player.y, game.player.width, game.player.height);
      ctx.shadowBlur = 0;

      // Draw CPU paddle (right - bright red)
      ctx.fillStyle = '#ff6b6b';
      ctx.fillRect(game.cpu.x, game.cpu.y, game.cpu.width, game.cpu.height);

      ctx.shadowColor = '#ff6b6b';
      ctx.shadowBlur = 20;
      ctx.fillRect(game.cpu.x, game.cpu.y, game.cpu.width, game.cpu.height);
      ctx.shadowBlur = 0;

      // Draw ball trail
      game.ball.trail.forEach((pos, i) => {
        ctx.globalAlpha = (i / game.ball.trail.length) * 0.5;
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, game.ball.radius * 0.7, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;

      // Draw ball (bright white)
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(game.ball.x, game.ball.y, game.ball.radius, 0, Math.PI * 2);
      ctx.fill();

      // Ball glow
      ctx.shadowColor = '#fff';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(game.ball.x, game.ball.y, game.ball.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Draw particles
      game.particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 30;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;

      // Draw replay indicator
      if (game.replay.active) {
        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#efc050';
        ctx.font = 'bold 64px monospace';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#efc050';
        ctx.shadowBlur = 20;
        ctx.fillText('REPLAY', canvas.width / 2, canvas.height / 2);

        ctx.font = 'bold 32px monospace';
        ctx.fillStyle = game.replay.scoredBy === 'Player' ? '#45b8ac' : '#ff6b6b';
        ctx.fillText(game.replay.scoredBy + ' Scored!', canvas.width / 2, canvas.height / 2 + 60);
        ctx.restore();
      }

      // Draw start screen after intro
      if (!game.running && !intro.active && !game.replay.active) {
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 32px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('CLICK TO START', canvas.width / 2, canvas.height / 2);
        ctx.font = 'bold 20px monospace';
        ctx.fillStyle = '#efc050';
        ctx.fillText('First to 10 wins!', canvas.width / 2, canvas.height / 2 + 40);
      }
    }

    // Game loop
    function gameLoop() {
      if (intro.active) {
        updateIntro();
        drawIntro();
      } else {
        update();
        draw();
      }
      requestAnimationFrame(gameLoop);
    }

    // Update UI
    function updateUI() {
      document.getElementById('playerScore').textContent = game.playerScore;
      document.getElementById('cpuScore').textContent = game.cpuScore;
      document.getElementById('rally').textContent = game.rally;
    }

    // Start game
    function startGame() {
      game.running = true;
      document.getElementById('gameOver').style.display = 'none';
      resetBall();
      updateUI();
    }

    // End game
    function endGame(winner) {
      game.running = false;
      document.getElementById('winnerText').textContent = winner === 'Player' ? 'You Win!' : 'CPU Wins!';
      document.getElementById('winnerText').style.color = winner === 'Player' ? '#00ff00' : '#ff6b6b';
      document.getElementById('finalPlayerScore').textContent = game.playerScore;
      document.getElementById('finalCPUScore').textContent = game.cpuScore;
      document.getElementById('gameOver').style.display = 'flex';
    }

    // Reset game
    function resetGame() {
      game.playerScore = 0;
      game.cpuScore = 0;
      game.rally = 0;
      game.ball.speed = 4;
      startGame();
    }

    // Start game loop
    gameLoop();
  </script>
</body>
</html>
